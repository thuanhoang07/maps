<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Map Example Using Javascript</title>

    <!-- Load the Google Maps API -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBRr6PMgMCG4GrlhCbO_wp466zIhddRJlg&callback=initMap"
            async defer></script>

    <script src="index.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<!-- Menu lựa chọn giữa Maps và History -->
<div>
    <select id="viewSelector" onchange="handleViewChange()">
        <option value="maps" selected>Maps</option> <!-- Mặc định là maps -->
        <option value="history">History</option>
    </select>
</div>

<!-- Map container -->
<div id="map"></div>

<p id="directions"></p> 

<script src="https://www.unpkg.com/@eohjsc/era-widget@1.0.14/src/index.js"></script>

<script>
    const eraWidget = new EraWidget();
    let configLAT = null;
    let configLON = null;
    let configGPSON = null;
    let configSPEED = null;
    let currentView = "maps"; // Mặc định là maps

    let LAT_his_Array_all = [];
    let LON_his_Array_all = [];
    let GPSON_his_Array = [];
    let pathCoordinatesHistory = [];

    // Thiết lập mặc định là chế độ Maps khi trang web được tải
    window.onload = function() {
        initMap(); // Khởi động bản đồ khi tải trang
    }

    function handleViewChange() {
        currentView = document.getElementById("viewSelector").value;

        if (currentView === "history") {
            console.log("History mode selected. Drawing historical path.");
            clearInterval(updateInterval); // Dừng cập nhật bản đồ hiện tại
            drawHistoryPath(); // Vẽ lại đường đi từ dữ liệu lịch sử
        } else if (currentView === "maps") {
            console.log("Maps mode selected. Resuming map updates.");
            document.getElementById("map").style.display = "block"; // Hiển thị bản đồ
            initMap(); // Khởi tạo lại bản đồ
        }
    }

    eraWidget.onConfiguration((configuration) => {
        configLAT = configuration.realtime_configs[0];
        configLON = configuration.realtime_configs[1];
        configGPSON = configuration.realtime_configs[2];
        configSPEED = configuration.realtime_configs[3];
        console.log("Configuration Loaded:", configuration);
    });

    eraWidget.requestHistories( 
        new Date().getTime() - 1000 * 60 * 60 * 24 * 30,
        new Date().getTime()
    );
    
    eraWidget.onHistories((histories) => { 
        console.log("onHistories:", histories);

        // Lưu lại giá trị lịch sử của LAT, LON và GPSON
        LAT_his_Array_all = histories[0].data;
        LON_his_Array_all = histories[1].data;
        GPSON_his_Array = histories[2].data;

        console.log("LAT_his_Array_all:", LAT_his_Array_all);
        console.log("LON_his_Array_all:", LON_his_Array_all);
        console.log("GPSON_his_Array:", GPSON_his_Array);

        // Lọc chỉ lấy những điểm khi GPSON = 1
        pathCoordinatesHistory = LAT_his_Array_all
            .map((latItem, index) => {
                if (GPSON_his_Array[index].y === 1) {
                    return { lat: latItem.y, lng: LON_his_Array_all[index].y };
                }
                return null;
            })
            .filter(coord => coord !== null);

        console.log("pathCoordinatesHistory:", pathCoordinatesHistory);
    });

    eraWidget.onValues((values) => {
        console.log("Value:", values);
        if (configLAT && values[configLAT.id]) {
            LAT = values[configLAT.id].value;
            console.log("Value LAT:", LAT);
        }
        if (configLON && values[configLON.id]) {
            LON = values[configLON.id].value;
            console.log("Value LON:", LON);
        }
        if (configGPSON && values[configGPSON.id]) {
            GPSON = values[configGPSON.id].value;
            console.log("Value GPSON:", GPSON);
        }
        if (configSPEED && values[configSPEED.id]) {
            SPEED = values[configSPEED.id].value;
            console.log("Value SPEED:", SPEED);
        }
    });

    eraWidget.ready();
</script>

<script>
    let map;
    let marker;
    let currentPath;
    let updateInterval;

    function initMap() {
        if (currentView !== "maps") return; // Nếu không phải chế độ maps thì thoát

        const options = {
            zoom: 14,
            center: { lat: LAT, lng: LON }
        };

        map = new google.maps.Map(document.getElementById('map'), options);

        marker = new google.maps.Marker({
            position: { lat: LAT, lng: LON },
            map: map
        });

        updateInterval = setInterval(updateMapCenter, 1000);
    }

    function updateMapCenter() {
        if (LAT && LON) {
            const newCenter = { lat: parseFloat(LAT), lng: parseFloat(LON) };

            map.setCenter(newCenter);
            marker.setPosition(newCenter);

            if (GPSON === 1) {
                const strokeColor = getRainbowColorForSpeed(SPEED);

                if (!currentPath || strokeColor !== currentColor) {
                    if (pathCoordinates.length > 0) {
                        currentPath.setPath(pathCoordinates); 
                    }
                    pathCoordinates = lastPosition ? [lastPosition] : [];
                    currentColor = strokeColor;
                    initializePath(strokeColor);
                }

                pathCoordinates.push(newCenter);
                currentPath.setPath(pathCoordinates); 
                
                lastPosition = newCenter;
            } else {
                if (currentPath) {
                    currentPath.setPath(pathCoordinates);
                }
                lastPosition = null; 
            }
        }
    }

    function drawHistoryPath() {
        if (pathCoordinatesHistory.length > 0) {
            const options = {
                zoom: 14,
                center: pathCoordinatesHistory[0]
            };

            map = new google.maps.Map(document.getElementById('map'), options);

            const historyPath = new google.maps.Polyline({
                path: pathCoordinatesHistory,
                geodesic: true,
                strokeColor: "#FF0000", // Màu đỏ cho đường lịch sử
                strokeOpacity: 1.0,
                strokeWeight: 4
            });

            historyPath.setMap(map);
        }
    }

    function initializePath(strokeColor) {
        currentPath = new google.maps.Polyline({
            path: [],
            geodesic: true,
            strokeColor: strokeColor,
            strokeOpacity: 1.0,
            strokeWeight: 4
        });
        currentPath.setMap(map);
    }

    function interpolateColor(color1, color2, factor) {
        return [
            Math.round(color1[0] + factor * (color2[0] - color1[0])),
            Math.round(color1[1] + factor * (color2[1] - color1[1])),
            Math.round(color1[2] + factor * (color2[2] - color1[2]))
        ];
    }

    function getRainbowColorForSpeed(speed) {
        const colors = [
            [255, 0, 0],    // Red
            [255, 165, 0],  // Orange
            [255, 255, 0],  // Yellow
            [0, 255, 0],    // Green
            [0, 0, 255],    // Blue
            [75, 0, 130],   // Indigo
            [238, 130, 238] // Violet
        ];

        const numColors = colors.length;
        const maxSpeed = 100;
        const segment = maxSpeed / (numColors - 1); 

        let startColorIndex = Math.floor(speed / segment);
        let endColorIndex = startColorIndex + 1;

        if (endColorIndex >= numColors) {
            endColorIndex = numColors - 1;
        }

        const factor = (speed % segment) / segment;
        const [r, g, b] = interpolateColor(colors[startColorIndex], colors[endColorIndex], factor);

        return `rgb(${r}, ${g}, ${b})`;
    }
</script>

<style>
    #map {
        height: 700px;
        width: 100%;
    }
</style>

</body>
</html>
